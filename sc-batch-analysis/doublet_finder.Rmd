---
output: 
  html_document:
    df_print: paged
    code_folding: hide
    code_download: true
    number_sections: true
    toc: true
    toc_float: true
params:
  title: "batch seurat doublet finder report"
  organism: "human"
  input_object: "out_rds_wc/sobj.separate.cc.rds"
  object_dir: "out_rds_wc/"
  mouse_rds: 'mouse_rds/'
  split_by: "sample"
  doublet_formation_rate: 0.05
  initial_dims: 20
  initial_resolution: 1.0
title: |
  | CUBI SCBA Single Cell Pipeline
  |
  | `r params$title`
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE, cache=FALSE, cache.lazy=FALSE, message=FALSE, warning=FALSE)


suppressPackageStartupMessages(library(DoubletFinder))
suppressPackageStartupMessages(library(Seurat))
suppressPackageStartupMessages(library(Matrix))
suppressPackageStartupMessages(library(fields))
suppressPackageStartupMessages(library(KernSmooth))
suppressPackageStartupMessages(library(ROCR))
suppressPackageStartupMessages(library(parallel))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(tidyr))
suppressPackageStartupMessages(library(dplyr))

options(future.globals.maxSize = 12 * 1024 * 1024^2)

```

# Analysis Parameters

For this analysis, we used the following parameters:

```{r print parameters}

data.frame(parameter=names(params), value=sapply(names(params), function(x) params[[x]])) %>%
  filter(parameter != "title") %>%
  tibble::remove_rownames()

```
# Doublet Finder

We start by identifying doublets using [Doublet Finder](https://github.com/chris-mcginnis-ucsf/DoubletFinder).

```{r identify_doublets, results = FALSE, fig.show = 'hide'}

possible_input_objects <- c("sobj.rds", "sobj.separate.cc.rds", "sobj.diff.cc.rds")

if (params$input_object %in% paste0(params$object_dir, possible_input_objects)){
  sobj <- readRDS(params$input_object)
    } else {
        stop("Please decide on object (sobj.rds|sobj.separate.cc.rds|sobj.diff.cc.rds)", call. = FALSE)
}


# doublets should be detected on non-integrated but normalized data; first, we split the object, so that inter-sample "artificial" doublets cannot be generated
DefaultAssay(sobj) <- "RNA" 
sobjs <- SplitObject(sobj, split.by = params$split_by)

find_doublets <- function(object){
  sweep.res.list_sobj <- paramSweep_v3(sobjs[[object]], PCs = 1:10, sct = FALSE)
  sweep.stats_sobj <- summarizeSweep(sweep.res.list_sobj, GT = FALSE)
  bcmvn_sobj <- find.pK(sweep.stats_sobj)
  annotations <- sobjs[[object]]@meta.data$seurat_clusters
  homotypic.prop <- modelHomotypic(annotations)
  nExp_poi <- round(params$doublet_formation_rate * nrow(sobjs[[object]]@meta.data))  ## Default 5% doublet formation rate - tailor for your dataset
  nExp_poi.adj <- round(nExp_poi*(1-homotypic.prop))
  sobjs.dups <- doubletFinder_v3(sobjs[[object]], PCs = 1:10, pN = 0.25, pK = 0.09, nExp = nExp_poi, reuse.pANN = FALSE, sct = FALSE)
}

dups <- lapply(names(sobjs), find_doublets)
names(dups) <- names(sobjs)

```

## Doublet statistics per sample
A maximum of eight plots corresponding to two samples are shown in this section. For a complete set of plots, see [Appendix].

```{r plot_dups_stats, results = FALSE}

s.dups <- dups

plot_dups_stats <- function(object){
  s.dups[[object]][["pANN"]] <- s.dups[[object]]@meta.data[,colnames(s.dups[[object]]@meta.data)[grepl("pANN",colnames(s.dups[[object]]@meta.data) )]]
  s.dups[[object]][["DF"]] <- s.dups[[object]]@meta.data[,colnames(s.dups[[object]]@meta.data)[grepl("DF",colnames(s.dups[[object]]@meta.data) )]]
  
  p1 <- DimPlot(s.dups[[object]],reduction='umap',label=T)+
    ggtitle(paste0(object,"_all_clusters"))
  p2 <- DimPlot(s.dups[[object]],reduction='umap', group.by="DF")+
    scale_colour_manual(values=c("dodgerblue3", "orange3")) +
    ggtitle(paste0(object, "_doublets_singlets"))
  
  p3 <- s.dups[[object]]@meta.data %>%
    dplyr::select(orig.ident, seurat_clusters, pANN, DF) %>%
    dplyr::group_by(seurat_clusters, DF) %>%
    dplyr::summarise(n = n()) %>%
    dplyr::mutate(frac = n/sum(n)) %>%
    ggplot(aes(seurat_clusters, frac, fill=DF)) + 
    geom_bar(stat = "identity") +
    scale_fill_manual(values=c("dodgerblue3", "orange3")) +
    ggtitle(paste0(object, "_doublets by cluster"))+
    ylab("fraction of cells")
  
  p4 <- s.dups[[object]]@meta.data %>%
    dplyr::select(orig.ident, seurat_clusters, pANN, DF) %>%
    ggplot(aes(seurat_clusters, pANN, fill=DF)) + 
    geom_boxplot(outlier.shape = NA) +
    scale_fill_manual(values=c("dodgerblue3", "orange3")) +
    ggtitle(paste0(object, "_doublet score"))+
    ylab("pANN")
  list(p1, p2, p3, p4)
}


if (length(names(s.dups))>2){
  plot_s.dups <- names(s.dups)[1:2]
} else {
  plot_s.dups <- names(s.dups)
}

lapply(plot_s.dups, plot_dups_stats)

```

```{r merge_dups_objects}

merge_dups_stats <- function(object){
  s.dups[[object]][["pANN"]] <- s.dups[[object]]@meta.data[,colnames(s.dups[[object]]@meta.data)[grepl("pANN",colnames(s.dups[[object]]@meta.data) )]]
  s.dups[[object]]@meta.data[,colnames(s.dups[[object]]@meta.data)[grepl("pANN_",colnames(s.dups[[object]]@meta.data) )]] <- NULL
  s.dups[[object]][["DF"]] <- s.dups[[object]]@meta.data[,colnames(s.dups[[object]]@meta.data)[grepl("DF",colnames(s.dups[[object]]@meta.data) )]]
  s.dups[[object]]@meta.data[,colnames(s.dups[[object]]@meta.data)[grepl("DF.classifications_",colnames(s.dups[[object]]@meta.data) )]] <- NULL
  s.dups[[object]]
}

s.dups <- lapply(names(s.dups), merge_dups_stats)
names(s.dups) <- names(sobjs)
if (length(s.dups)>1){
  sobj.dups <- merge(s.dups[[1]],s.dups[2:length(names(s.dups))], merge.data = T)
} else if (length(s.dups)==1){
  sobj.dups <- s.dups[[1]]
}

s.dups <- dups

```

## Common doublet statistics

```{r plot_common_stats}

sobj.dups@meta.data$seurat_clusters <- factor(sobj.dups@meta.data$seurat_clusters,
                                              levels = seq(0, max(as.numeric(as.character(sobj.dups@meta.data$seurat_clusters)))))

sobj.dups@meta.data %>%
  dplyr::select(sample, seurat_clusters, pANN, DF) %>%
  dplyr::group_by(seurat_clusters, DF) %>%
  dplyr::summarise(n = n()) %>%
  dplyr::mutate(frac = n/sum(n)) %>%
  ggplot(aes(seurat_clusters, frac, fill=DF)) + 
  geom_bar(stat = "identity") +
  scale_fill_manual(values=c("dodgerblue3", "orange3")) +
  ggtitle("doublets by cluster: all samples")+
  ylab("fraction of cells")

sobj.dups@meta.data %>%
  dplyr::select(sample, seurat_clusters, pANN, DF) %>%
  ggplot(aes(seurat_clusters, pANN, fill=DF)) + 
  geom_boxplot(outlier.shape = NA) +
  scale_fill_manual(values=c("dodgerblue3", "orange3")) +
  ggtitle("doublet score: all samples")+
  ylab("pANN")

sobj.dups@meta.data %>%
  dplyr::select(sample, seurat_clusters, pANN, DF) %>%
  dplyr::group_by(sample, DF) %>%
  dplyr::summarise(n = n()) %>%
  dplyr::mutate(frac = n/sum(n)) %>%
  ggplot(aes(sample, frac, fill=DF)) + 
  geom_bar(stat = "identity") +
  scale_fill_manual(values=c("dodgerblue3", "orange3")) +
  theme(axis.text.x = element_text(angle=45,vjust=1,hjust=1)) +
  ggtitle("doublets by sample: all clusters")+
  ylab("fraction of cells")


```


## Doublet removal

After doublet removal, we will keep `r round(nrow(subset(sobj.dups@meta.data, DF =="Singlet"))/nrow(sobj.dups@meta.data)*100, digits = 2)` % of cells.

We remove them and perform the standard Seurat workflow followed by data integration.

```{r remove_doublets}

sobj.singlet <- subset(sobj.dups, DF == "Singlet")

```

# Cell cycle regression and clustering

Here, we compare two cell cycle scoring regression approaches in the standard Seurat pre-processing workflow. We try to address the following: 1. are cycling cells present in the data and will they significantly affect clustering? 2. does regression off cell cycle scores remove the cell cycle effects? 3. does the regression of difference in S and G2M scores perform better?

## Top genes in principal components

Display the genes in the first 10 principal components to understand if there are cell cycle genes present. 

```{r process, message = TRUE}
sobj <- sobj.singlet
DefaultAssay(sobj) <- "RNA"

if (params$organism == "mouse"){

s.genes<-readRDS(file.path(params$mouse_rds, "s_genes_mouse.rds"))
g2m.genes<-readRDS(file.path(params$mouse_rds, "g2m_genes_mouse.rds"))
    
} else if (params$organism == "human"){
  
s.genes<-cc.genes$s.genes
g2m.genes<-cc.genes$g2m.genes
  
} else {
  stop("Error: your organism is not supported. Only mouse or human for now.")
}

sobj <- sobj %>%
  NormalizeData(normalization.method='LogNormalize',scale.factor=10000,verbose=FALSE) %>%
  FindVariableFeatures(selection.method='vst',nfeatures=2000,verbose=FALSE) %>%
  ScaleData(vars.to.regress=c('nCount_RNA'),verbose=FALSE)

cat("showing genes in PCs without any cell cycle regression...", stdout())
sobj <- RunPCA(sobj, features = VariableFeatures(sobj), ndims.print = 1:10, nfeatures.print = 10)

sobj <- CellCycleScoring(sobj, s.features = s.genes, g2m.features = g2m.genes, set.ident = T)
sobj$cc.diff <- sobj$S.Score - sobj$G2M.Score

sobj <- sobj %>%
  FindNeighbors(dims=1:params$initial_dims,verbose=FALSE) %>%
  RunUMAP(dims=1:params$initial_dims,verbose=FALSE) %>%
  FindClusters(resolution=params$initial_resolution, verbose=FALSE)

sobj.separate.cc <- sobj %>%
  ScaleData(vars.to.regress=c('S.Score','G2M.Score'),verbose=FALSE) 

cat("showing genes in PCs with regression of separate G2M and S scores...", stdout())
sobj.separate.cc <- RunPCA(sobj.separate.cc, features = VariableFeatures(sobj.separate.cc), ndims.print = 1:10, nfeatures.print = 10)

sobj.separate.cc <- sobj.separate.cc %>%
  FindNeighbors(dims=1:params$initial_dims,verbose=FALSE) %>%
  RunUMAP(dims=1:params$initial_dims,verbose=FALSE) %>%
  FindClusters(resolution=params$initial_resolution, verbose=FALSE)

sobj.diff.cc <- sobj %>%
  ScaleData(vars.to.regress=c('cc.diff'),verbose=FALSE)

cat("showing genes in PCs with regression of difference in G2M and S scores...", stdout())
sobj.diff.cc <- RunPCA(sobj.diff.cc, features = VariableFeatures(sobj.diff.cc), ndims.print = 1:10, nfeatures.print = 10)

sobj.diff.cc <- sobj.diff.cc %>%
  FindNeighbors(dims=1:params$initial_dims,verbose=FALSE) %>%
  RunUMAP(dims=1:params$initial_dims,verbose=FALSE) %>%
  FindClusters(resolution=params$initial_resolution, verbose=FALSE)

```

## Dimensionality of the data
Check the dimensionality of the data. How many PCs account for most of the variation in the dataset?

```{r check_dim}

ElbowPlot(sobj)

```

## Cell cycle scoring

### Detected cell cyle phase vs. score based on cell cycle genes

```{r plot_cc_scores, fig.height=4, fig.width=7}

sobj@meta.data %>%
  dplyr::select(Phase, S.Score, G2M.Score) %>%
  gather(score_type,score,-Phase) %>%
  ggplot(aes(score_type, score, fill = Phase)) + geom_violin(scale = "count")
```

### Comparison of cell cycle regression approaches - UMAP

```{r plot, fig.width=8, fig.height=5}

# DimPlot(sobj, reduction='umap', group.by='sample') + ggtitle("no cell cycle regression")
DimPlot(sobj, reduction='umap', group.by='Phase') + ggtitle("no cell cycle regression")

# DimPlot(sobj.separate.cc, reduction='umap', group.by='sample') + ggtitle("separate S and G2M scores regressed")
DimPlot(sobj.separate.cc, reduction='umap', group.by='Phase') + ggtitle("separate S and G2M scores regressed")

# DimPlot(sobj.diff.cc, reduction='umap', group.by='sample') + ggtitle("difference in S and G2M scores regressed")
DimPlot(sobj.diff.cc, reduction='umap', group.by='Phase') + ggtitle("difference in S and G2M scores regressed")

```

### Comparison of cell cycle regression approaches - fractions per cluster
```{r plot_clusters_cell_cycle, fig.height=4, fig.width=7}
sobj@meta.data %>%
  dplyr::select(seurat_clusters, Phase) %>%
  dplyr::group_by(seurat_clusters, Phase) %>%
  dplyr::summarise(n=n()) %>%
  dplyr::mutate(frac=n/sum(n)*100) %>%
  ggplot(aes(seurat_clusters, frac, fill = Phase)) + geom_bar(stat = "identity") +
  ylab("% cells in cluster") + 
  ggtitle("no cell cycle regression")

sobj.separate.cc@meta.data %>%
  dplyr::select(seurat_clusters, Phase) %>%
  dplyr::group_by(seurat_clusters, Phase) %>%
  dplyr::summarise(n=n()) %>%
  dplyr::mutate(frac=n/sum(n)*100) %>%
  ggplot(aes(seurat_clusters, frac, fill = Phase)) + geom_bar(stat = "identity") +
  ylab("% cells in cluster") + 
  ggtitle("separate S and G2M scores regressed")

sobj.diff.cc@meta.data %>%
  dplyr::select(seurat_clusters, Phase) %>%
  dplyr::group_by(seurat_clusters, Phase) %>%
  dplyr::summarise(n=n()) %>%
  dplyr::mutate(frac=n/sum(n)*100) %>%
  ggplot(aes(seurat_clusters, frac, fill = Phase)) + geom_bar(stat = "identity") +
  ylab("% cells in cluster") + 
  ggtitle("difference in S and G2M scores regressed")

```

## Fraction of cell cycle phase cells according to G2M and S score.

```{r fraction_display}
no_reg <- sobj@meta.data %>%
  dplyr::group_by(Phase) %>%
  dplyr::summarise(n=n()) %>%
  dplyr::mutate(pct_cell_cycle = round(n/sum(n)*100, digits=2)) %>%
  dplyr::select(Phase, pct_cell_cycle)

no_reg

```


Finally, Seurat R objects are stored.

```{r write_rds}

dir.create(params$object_dir, recursive = T, showWarnings = F)
saveRDS(sobj, file.path(params$object_dir,"sobj.df.rds"))
saveRDS(sobj.separate.cc, file.path(params$object_dir,"sobj.df.separate.cc.rds"))
saveRDS(sobj.diff.cc, file.path(params$object_dir,"sobj.df.diff.cc.rds"))

```

# Appendix
## Remaining doublet statistics per sample

```{plot remaining stats, eval = length(names(s.dups))>2, results = F, echo = length(names(s.dups))>2}

remaining_s.dups <- setdiff(names(s.dups), plot_s.dups)

lapply(remaining_s.dups, plot_dups_stats)

```

```{r sessionInfo}

sessionInfo()
```
